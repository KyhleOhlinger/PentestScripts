from neo4j import GraphDatabase

uri = "bolt://localhost:7687"
driver = GraphDatabase.driver(uri, auth=("<USERNAME>", "<PASSWORD>"))

ACLs = [
    "GenericWrite",
    "GenericAll",
    "ForceChangePassword",
    "Owns",
    "FullControl",
    "WriteDacl",
    "WriteOwner",
    "WriteProperty",
    "AllExtendedRights",
    "AddMember"
]

Objects = [
        "User",
        "Group",
        "Computer"
]
global Tier0Groups,domain,check, uniqueAccounts, increaseTier0, additionalGroups
global LaTeX, File, Req_Out, ACL_Check
global Tier0Dictionary, ACLDictionary

Tier0Groups = [
        "ENTERPRISE ADMINS",
        "DOMAIN ADMINS",
        "DNSADMINS",
        "SCHEMA ADMINS",
        "ADMINISTRATORS",
        "ACCOUNT OPERATORS",
        "BACKUP OPERATORS",
        "PRINT OPERATORS",
        "SERVER OPERATORS",
        "DOMAIN CONTROLLERS",
        "READ-ONLY DOMAIN CONTROLLERS",
        "GROUP POLICY CREATOR OWNERS",
        "CRYPTOGRAPHIC OPERATORS",
        "DISTRIBUTED COM USERS",
]

#Global Variables
domain = "DOMAIN.NAME"
check = True
increaseTier0 = True 
LaTeX = False
ACL_Check = False
uniqueAccounts = []
additionalGroups = []

Tier0Dictionary = {}
ACLDictionary = {}


def print_acl(tx,acl,object):
    global ACLDictionary
    printonce = False
    for obj in range(len(Objects)):        
        for record in tx.run("MATCH (a:"+object+")-[:"+acl+"]->(u:"+Objects[obj]+") RETURN a.name,COUNT(u.name),a.enabled"):
                if str(record["a.name"]).split("@", 1)[0] not in Tier0Groups and str(record["a.name"]) not in uniqueAccounts:
                        if not printonce:
                                print(object +" object with "+acl+" over a "+Objects[obj]+" object:\n----------------------------------")
                                printonce=True
                        if LaTeX:
                            ACLDictionary.setdefault(object, []).append(str(record["a.name"]) +":"+acl+ ":"+Objects[obj]+":" + str(record["COUNT(u.name)"]))
                        print("Account: "+record["a.name"]+"\t : Accounts Affected = "+str(record["COUNT(u.name)"]) + "\t : Account Enabled = "+str(record["a.enabled"])+"\n") 
        printonce = False

def StripTier0(tx):
        global Tier0Dictionary
        for tier0 in range(len(Tier0Groups)):
                if not check:
                        print("\n"+Tier0Groups[tier0]+"\n-------------------------------")     
                for record in tx.run("MATCH (n)-[r:MemberOf]->(g:Group {name:'"+Tier0Groups[tier0].upper()+"@"+domain.upper()+"'}) RETURN n.name"):
                        if not check:
                                print(record["n.name"]) 
                                if LaTeX:
                                    Tier0Dictionary.setdefault(Tier0Groups[tier0], []).append(record["n.name"])
                                    
                        #If you want unique accounts:
                        if str(record["n.name"]) not in uniqueAccounts and str(record["n.name"]).split("@", 1)[0] not in Tier0Groups:
                                uniqueAccounts.append(str(record["n.name"]))

def GetTier0Groups(tx):
        global increaseTier0
        increaseTier0 = False
        for acc in range(len(uniqueAccounts)):
                for record in tx.run("MATCH (g:Group) where g.name='"+uniqueAccounts[acc].upper()+"' RETURN g.name"):
                        if str(record["g.name"]).split("@", 1)[0] not in Tier0Groups:
                                increaseTier0 = True
                                Tier0Groups.append(str(record["g.name"]).split("@", 1)[0])
                                additionalGroups.append(str(record["g.name"]).split("@", 1)[0])

def print_latex():
    File.write("\\begin{longtable}{ m{7cm} | m{10cm}}\n")
    File.write("\\centering \\rowcolor{theadcolour} \\color{white} \\bf Tier 0 Group & \n")
    File.write("\\centering \\rowcolor{theadcolour} \\color{white} \\bf Tier 0 Members \n")
    File.write("\\endhead")
    
    for group in Tier0Dictionary:
        File.write("\\hline")
        for member in range(len(Tier0Dictionary[group])):
            if str(Tier0Dictionary[group][member]) == str(Tier0Dictionary[group][-1]):
                File.write("\multirow{-"+str(len(Tier0Dictionary[group]))+"}{*}{\\centering \\bold{"+str(group).replace('$', r'\$').replace('_', r'\_')+"}}" + "&"+str(Tier0Dictionary[group][member]).replace('$', r'\$').replace('_', r'\_')+"\\\\\n")
            else:
                File.write("&"+str(Tier0Dictionary[group][member]).replace('$', r'\$').replace('_', r'\_')+"\\\\\n")
    File.write("\\rowcolor{white}\\captionsetup{justification=centering}\\caption{Direct Tier 0 Group Members}")
    File.write("\\label{Direct Tier 0 Group Members}")
    File.write("\\end{longtable}")

def acl_out():
    print ACLDictionary
    for ACL in ACLDictionary:
        tempDict = {}
        File.write("\n\n")
        File.write("\\begin{longtable}{ m{4cm} | m{9cm} | m{4cm}}\n")
        File.write("\\centering \\rowcolor{theadcolour} \\color{white} \\bf Access Control List & \n")
        File.write("\\centering \\rowcolor{theadcolour} \\color{white} \\bf Object Name & \n")
        File.write("\\centering \\rowcolor{theadcolour} \\color{white} \\bf Control Count & \n")
        File.write("\\endhead")
        
        for objectType in range(len(ACLDictionary[ACL])):
            if str(ACLDictionary[ACL][objectType]).split(":")[3] == "1":
                tempDict.setdefault(str(ACLDictionary[ACL][objectType]).split(":")[1], []).append(str(ACLDictionary[ACL][objectType]).split(":")[0].replace('$', r'\$').replace('_', r'\_')+"&" + str(ACLDictionary[ACL][objectType]).split(":")[3]+" "+str(ACLDictionary[ACL][objectType]).split(":")[2] +" object")
            else:
                tempDict.setdefault(str(ACLDictionary[ACL][objectType]).split(":")[1], []).append(str(ACLDictionary[ACL][objectType]).split(":")[0].replace('$', r'\$').replace('_', r'\_')+"&" + str(ACLDictionary[ACL][objectType]).split(":")[3]+" "+str(ACLDictionary[ACL][objectType]).split(":")[2] +" objects")

        for access in tempDict:
            File.write("\\hline")
            for objects in range(len(tempDict[access])):
                if str(tempDict[access][objects]) == str(tempDict[access][-1]):
                    File.write("\multirow{-"+str(len(tempDict[access]))+"}{*}{\\centering \\bold{"+str(access)+"}}" + "&"+str(tempDict[access][objects])+"\\\\\n")
                else:
                    File.write("&"+str(tempDict[access][objects])+"\\\\\n")
        File.write("\\rowcolor{white}\\captionsetup{justification=centering}\\caption{"+str(ACL)+" objects with control over AD objects}")
        File.write("\\label{"+str(ACL)+" objects with control over AD objects}")
        File.write("\\end{longtable}")

def main(): 
        # Initial Checks
        global check
        while(increaseTier0):       
                with driver.session() as session:
                        # Retrieve Direct Tier0 Group Members 
                        session.read_transaction(StripTier0)
                        # Determine all Direct Tier0 groups - In addition to the Array of Microsoft groups
                        session.read_transaction(GetTier0Groups)
        session.close()
        check = False
        #Print Groups after Initial Checks
        with driver.session() as session:
                # Retrieve Direct Tier0 Group Members
                print("\n================================================================")
                print("Checking Tier 0 Group Members")
                print("================================================================")
                if LaTeX:
                    session.read_transaction(StripTier0)
                    print_latex()

                else:
                    session.read_transaction(StripTier0)
                
                print("\n-------------------------------\nAdditional Tier0 Groups:\n-------------------------------")
                for j in range(len(additionalGroups)):
                        print(additionalGroups[j])
                        if str(additionalGroups[j]+"@"+domain) in uniqueAccounts:
                                uniqueAccounts.remove(str(additionalGroups[j]+"@"+domain))

                print("\n-------------------------------\nUnique Tier0 Users:\n-------------------------------")
                for i in range(len(uniqueAccounts)):
                        print(uniqueAccounts[i])
        session.close()

def ACL_Checks():
        # Retrieve ACL Permissions
        with driver.session() as session:
                for obj in range(len(Objects)):
                        print("\n\n================================================================")
                        print("Checking "+Objects[obj]+" Permissions")
                        print("================================================================")
                        for i in range(len(ACLs)):
                                session.read_transaction(print_acl,ACLs[i],Objects[obj])
                        print("================================================================")
        session.close()


print("\n================================================================\n\t\t Welcome to ACL_Checker \n================================================================\n")

ACL_Out = raw_input("Do you want to generate ACL Information? [Y,N,Default=N]")      
Req_Out = raw_input("Do you want to generate ShareLaTeX output? [Y,N,Default=N]")

if Req_Out == "Y" or Req_Out == "y":
        File= open("ShareLaTeX_Output.txt","w+")
        LaTeX = True

main()
if ACL_Out == "Y" or ACL_Out == "y":
        ACL_Check = True
        ACL_Checks()
        if LaTeX:
            acl_out()

if LaTeX:
        File.close()
